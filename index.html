<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cesar Lattes 2002</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Major+Mono+Display&display=swap" rel="stylesheet">
    <style>
        /* CSS com tema Cyberpunk / Viperwave */
        :root {
            --cor-fundo-1: #0d0221;
            --cor-fundo-2: #241b47;
            --cor-grade: #ff00c1;
            --cor-cobra-1: #adff00;
            --cor-cobra-2: #00a878;
            --cor-cobra-cabeca: #eaff7b; /* <-- Variável nova adicionada */
            --cor-texto: #00f5d4;
            --cor-texto-sombra: #ff00c1;
            --tamanho-grid: 21; /* Usar número ímpar ajuda a centralizar */
        }

        @keyframes backgroundShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @keyframes textGlitch {
            0%, 100% { text-shadow: -1.5px -1.5px 0 var(--cor-texto-sombra), 1.5px 1.5px 0 var(--cor-texto); }
            25% { text-shadow: 1.5px 1.5px 0 var(--cor-texto-sombra), -1.5px -1.5px 0 var(--cor-texto); }
            50% { text-shadow: -1.5px 1.5px 0 var(--cor-texto-sombra), 1.5px -1.5px 0 var(--cor-texto); }
            75% { text-shadow: 1.5px -1.5px 0 var(--cor-texto-sombra), -1.5px 1.5px 0 var(--cor-texto); }
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: linear-gradient(270deg, var(--cor-fundo-1), var(--cor-fundo-2), var(--cor-fundo-1));
            background-size: 600% 600%;
            animation: backgroundShift 15s ease infinite;
            font-family: 'Major Mono Display', monospace;
            color: var(--cor-texto);
            flex-direction: column;
            overflow: hidden;
        }
        
        /* Efeito de Scanlines (tela antiga) */
        body::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(0deg, rgba(0,0,0,0.3), rgba(0,0,0,0.3) 1px, transparent 1px, transparent 3px);
            pointer-events: none;
            z-index: 100;
        }

        h1 {
            font-size: 3rem;
            animation: textGlitch 0.25s infinite;
        }
        
        #game-board {
            display: grid;
            grid-template-rows: repeat(var(--tamanho-grid), 1fr);
            grid-template-columns: repeat(var(--tamanho-grid), 1fr);
            width: 90vmin;
            height: 90vmin;
            max-width: 600px;
            max-height: 600px;
            background-color: transparent;
            /* Grade de neon feita com background-image */
            background-image: 
                linear-gradient(to right, var(--cor-grade) 1px, transparent 1px),
                linear-gradient(to bottom, var(--cor-grade) 1px, transparent 1px);
            background-size: calc(100% / var(--tamanho-grid)) calc(100% / var(--tamanho-grid));
            border: 2px solid var(--cor-grade);
            box-shadow: 0 0 20px var(--cor-grade), inset 0 0 20px var(--cor-grade);
            border-radius: 5px;
        }

        .snake {
            /* Efeito de volume com gradiente radial */
            background: radial-gradient(circle at 60% 40%, var(--cor-cobra-1) 60%, var(--cor-cobra-2) 100%);
            box-shadow: 0 0 12px var(--cor-cobra-1), 0 0 2px var(--cor-cobra-2) inset;
            border-radius: 50%;
            position: relative;
            z-index: 1;
            transition: box-shadow 0.2s;
        }

        .snake-head {
            /* MODIFICADO: Usa a nova variável --cor-cobra-cabeca */
            background: radial-gradient(circle at 60% 40%, var(--cor-cobra-cabeca) 70%, var(--cor-cobra-1) 100%);
            border-radius: 50%;
            box-shadow: 0 0 18px var(--cor-cobra-cabeca), 0 0 4px var(--cor-cobra-1) inset;
            position: relative;
            z-index: 2;
        }

        /* Olhos da cobra */
        .snake-head .eye {
            position: absolute;
            width: 18%;
            height: 18%;
            background: #222;
            border-radius: 50%;
            top: 30%;
            left: 20%;
            z-index: 3;
        }

        .snake-head .eye.right {
            left: auto;
            right: 20%;
        }

        .food {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: calc(50vmin / var(--tamanho-grid)); /* Tamanho da maçã responsivo */
            filter: drop-shadow(0 0 3px #ff0000); /* Sombra para o emoji */
            transform: scale(1.1);
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .score-container {
            font-size: 1.5rem;
            margin-bottom: 10px;
            text-shadow: 0 0 5px var(--cor-texto-sombra);
        }

        #score {
            color: var(--cor-cobra-1);
            font-size: 1.8rem;
        }

        /* Estilos para os botões de toque */
        .touch-btn {
            background: var(--cor-grade);
            color: var(--cor-fundo-1);
            font-size: 2rem;
            border: none;
            border-radius: 8px;
            box-shadow: 0 0 8px var(--cor-grade);
            padding: 18px 28px;
            margin: 0;
            font-family: inherit;
            cursor: pointer;
            transition: background 0.2s;
        }

        .touch-btn:active {
            background: var(--cor-cobra-1);
            color: var(--cor-fundo-2);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Cesar Lattes 2002</h1>
        <div class="score-container">SCORE: <span id="score">0</span></div>
    </div>

    <div id="touch-controls" style="display: none;">
        <div style="display: flex; flex-direction: column; align-items: center; gap: 10px;">
            <button class="touch-btn" data-dir="up">▲</button>
            <div style="display: flex; gap: 10px;">
                <button class="touch-btn" data-dir="left">◀</button>
                <button class="touch-btn" data-dir="down">▼</button>
                <button class="touch-btn" data-dir="right">▶</button>
            </div>
        </div>
    </div>
    
    <div id="game-board"></div>
    
    <button id="toggle-ai" style="margin-bottom: 15px; font-size: 1.2rem; background: var(--cor-grade); color: var(--cor-fundo-1); border-radius: 8px; border: none; padding: 10px 18px; cursor: pointer; box-shadow: 0 0 8px var(--cor-grade);">Ativar IA</button>

    <audio id="background-music" loop>
        <source src="https://cdn.pixabay.com/download/audio/2023/01/18/audio_623812d116.mp3" type="audio/mpeg">
    </audio>

    <script>
        // --- CONFIGURAÇÕES GERAIS ---
        const GRID_SIZE = 21; // Mesmo valor do CSS
        const STARTING_SPEED = 200; // Começa um pouco mais devagar
        const gameBoard = document.getElementById('game-board');
        const scoreDisplay = document.getElementById('score');
        const music = document.getElementById('background-music');
        
        let snake = [{ x: 11, y: 11 }]; // Posição inicial no centro
        let food = generateFood();
        let direction = { x: 0, y: 0 };
        let score = 0;

        // MODIFICADO: Adicionada cor da cabeça na primeira posição
        const snakeColors = [
            ["#eaff7b", "#adff00", "#00a878"], // verde limão (cabeça, corpo1, corpo2)
            ["#6dffef", "#00f5d4", "#1982c4"], // verde água
            ["#ff79e7", "#ff00c1", "#6a4c93"], // rosa neon
            ["#fff0a3", "#ffe066", "#ff595e"], // amarelo
            ["#6dffef", "#00a878", "#adff00"], // verde escuro
            ["#ffacaf", "#ff595e", "#ffe066"], // vermelho
            ["#80c9f1", "#1982c4", "#00f5d4"], // azul
            ["#b399d3", "#6a4c93", "#ff00c1"]  // roxo
        ];
        let currentColorIndex = 0;
        let gameStarted = false;
        let gameSpeed = STARTING_SPEED;

        // --- LÓGICA DO JOGO ---
        function main() {
            if (aiEnabled) aiMove(); // Chama IA se ativada
            update();
            draw();
        }

        function update() {
            const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };
            snake.unshift(head);

            if (head.x === food.x && head.y === food.y) {
                score++;
                scoreDisplay.innerText = score;

                // MODIFICADO: Atualiza a cor da cabeça junto com o corpo
                if (score % 10 === 0) {
                    currentColorIndex = (currentColorIndex + 1) % snakeColors.length;
                    document.documentElement.style.setProperty('--cor-cobra-cabeca', snakeColors[currentColorIndex][0]);
                    document.documentElement.style.setProperty('--cor-cobra-1', snakeColors[currentColorIndex][1]);
                    document.documentElement.style.setProperty('--cor-cobra-2', snakeColors[currentColorIndex][2]);
                }

                food = generateFood();
                if (gameSpeed > 70) { // Aumenta a velocidade até um limite
                    gameSpeed -= 5;
                    clearInterval(gameInterval);
                    gameInterval = setInterval(main, gameSpeed);
                }
            } else {
                snake.pop();
            }

            if (checkCollision(head)) {
                music.pause();
                alert(`// SYSTEM FAILURE // SCORE: ${score}. PRESS OK TO REBOOT.`);
                window.location.reload();
            }
        }

        function draw() {
            gameBoard.innerHTML = '';
            snake.forEach((segment, index) => {
                const snakeElement = document.createElement('div');
                snakeElement.style.gridRowStart = segment.y;
                snakeElement.style.gridColumnStart = segment.x;

                // Aplica cor e formato conforme animal selecionado
                if (index === 0) {
                    snakeElement.classList.add('snake-head');
                    const leftEye = document.createElement('div');
                    leftEye.classList.add('eye');
                    const rightEye = document.createElement('div');
                    rightEye.classList.add('eye', 'right');
                    snakeElement.appendChild(leftEye);
                    snakeElement.appendChild(rightEye);
                } else {
                    snakeElement.classList.add('snake');
                }

                gameBoard.appendChild(snakeElement);
            });

            // Comida
            const foodElement = document.createElement('div');
            foodElement.style.gridRowStart = food.y;
            foodElement.style.gridColumnStart = food.x;
            foodElement.classList.add('food');
            foodElement.innerText = '🍎';
            gameBoard.appendChild(foodElement);
        }

        function generateFood() {
            let newFoodPosition;
            while (newFoodPosition == null || onSnake(newFoodPosition)) {
                newFoodPosition = {
                    x: Math.floor(Math.random() * GRID_SIZE) + 1,
                    y: Math.floor(Math.random() * GRID_SIZE) + 1
                };
            }
            return newFoodPosition;
        }

        function onSnake(position) {
            return snake.some(segment => segment.x === position.x && segment.y === position.y);
        }

        function checkCollision(head) {
            const hitWall = head.x < 1 || head.x > GRID_SIZE || head.y < 1 || head.y > GRID_SIZE;
            const hitSelf = snake.slice(1).some(segment => segment.x === head.x && segment.y === head.y);
            return hitWall || hitSelf;
        }

        // --- CONTROLES E MÚSICA ---
        function startGame() {
            if (!gameStarted) {
                music.volume = 0.5;
                music.play().catch(e => {});
                gameStarted = true;
            }
        }
        
        window.addEventListener('keydown', e => {
            if (!gameStarted) startGame();
            switch (e.key) {
                case 'ArrowUp': if (direction.y === 0) direction = { x: 0, y: -1 }; break;
                case 'ArrowDown': if (direction.y === 0) direction = { x: 0, y: 1 }; break;
                case 'ArrowLeft': if (direction.x === 0) direction = { x: -1, y: 0 }; break;
                case 'ArrowRight': if (direction.x === 0) direction = { x: 1, y: 0 }; break;
            }
        });

        // Garante que a música toque após qualquer clique/touch do usuário
        document.body.addEventListener('click', () => {
            if (!gameStarted) startGame();
            music.play().catch(() => {});
        });
        document.body.addEventListener('touchstart', () => {
            if (!gameStarted) startGame();
            music.play().catch(() => {});
        });

        // --- INÍCIO ---
        let gameInterval = setInterval(main, gameSpeed);

        // --- CONTROLES DE TOQUE (MÓVEL) ---
        const touchControls = document.getElementById('touch-controls');
        const touchButtons = document.querySelectorAll('.touch-btn');

        // Mostrar controles de toque se em um dispositivo móvel
        function isMobile() {
            return /Android|iPhone|iPad|iPod|Opera Mini|IEMobile|Mobile/i.test(navigator.userAgent);
        }

        if (isMobile()) {
            document.getElementById('touch-controls').style.display = 'block';
        }

        document.querySelectorAll('.touch-btn').forEach(btn => {
            btn.addEventListener('touchstart', e => {
                e.preventDefault();
                startGame();
                const dir = btn.getAttribute('data-dir');
                switch (dir) {
                    case 'up':    if (direction.y === 0) direction = { x: 0, y: -1 }; break;
                    case 'down':  if (direction.y === 0) direction = { x: 0, y: 1 }; break;
                    case 'left':  if (direction.x === 0) direction = { x: -1, y: 0 }; break;
                    case 'right': if (direction.x === 0) direction = { x: 1, y: 0 }; break;
                }
            });
        });

        let aiEnabled = false;
        const aiButton = document.getElementById('toggle-ai');
        aiButton.addEventListener('click', () => {
            aiEnabled = !aiEnabled;
            aiButton.innerText = aiEnabled ? "Desativar IA" : "Ativar IA";
        });

        // Função IA aprimorada: evita colisão com a cauda
        function aiMove() {
            const head = snake[0];
            const possibleMoves = [
                { x: 0, y: -1, name: 'up' },
                { x: 0, y: 1, name: 'down' },
                { x: -1, y: 0, name: 'left' },
                { x: 1, y: 0, name: 'right' }
            ];

            // Ordena por distância até a comida
            possibleMoves.sort((a, b) => {
                const distA = Math.abs((head.x + a.x) - food.x) + Math.abs((head.y + a.y) - food.y);
                const distB = Math.abs((head.x + b.x) - food.x) + Math.abs((head.y + b.y) - food.y);
                return distA - distB;
            });

            // Simula cada movimento e escolhe o mais seguro
            for (const move of possibleMoves) {
                // Evita reversão de direção
                if ((move.x === -direction.x && move.y === -direction.y)) continue;
                const nextPos = { x: head.x + move.x, y: head.y + move.y };

                // Verifica se o próximo movimento é seguro
                if (
                    nextPos.x >= 1 && nextPos.x <= GRID_SIZE &&
                    nextPos.y >= 1 && nextPos.y <= GRID_SIZE &&
                    !snake.some(segment => segment.x === nextPos.x && segment.y === nextPos.y)
                ) {
                    // Simula o movimento: verifica se há pelo menos um movimento seguro depois deste
                    let safeNext = false;
                    for (const nextMove of possibleMoves) {
                        if ((nextMove.x === -move.x && nextMove.y === -move.y)) continue;
                        const futurePos = { x: nextPos.x + nextMove.x, y: nextPos.y + nextMove.y };
                        if (
                            futurePos.x >= 1 && futurePos.x <= GRID_SIZE &&
                            futurePos.y >= 1 && futurePos.y <= GRID_SIZE &&
                            !snake.some(segment => segment.x === futurePos.x && segment.y === futurePos.y) &&
                            !(futurePos.x === head.x && futurePos.y === head.y) // não volta pra cabeça
                        ) {
                            safeNext = true;
                            break;
                        }
                    }
                    if (safeNext) {
                        direction = { x: move.x, y: move.y };
                        return;
                    }
                }
            }

            // Se não encontrou movimento seguro, faz o primeiro possível (evita travar)
            for (const move of possibleMoves) {
                if ((move.x === -direction.x && move.y === -direction.y)) continue;
                const nextPos = { x: head.x + move.x, y: head.y + move.y };
                if (
                    nextPos.x >= 1 && nextPos.x <= GRID_SIZE &&
                    nextPos.y >= 1 && nextPos.y <= GRID_SIZE &&
                    !snake.some(segment => segment.x === nextPos.x && segment.y === nextPos.y)
                ) {
                    direction = { x: move.x, y: move.y };
                    return;
                }
            }
        }
    </script>
</body>
</html>